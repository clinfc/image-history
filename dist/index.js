(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ImageHistory"] = factory();
	else
		root["ImageHistory"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n\n  privateMap.set(receiver, value);\n  return value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n};\n\nvar _root, _listener, _observer, _mirroring, _changed, _rules;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction attributeFilter(listener) {\n  const filter = [];\n  Object.values(listener).forEach(row => {\n    filter.push(...row);\n  });\n  return filter;\n}\n\nfunction isValidElem(listener, node) {\n  return node instanceof Element && listener[node.nodeName] instanceof Set;\n}\n\nfunction isValidAttr(listener, node, attr) {\n  return attr && node instanceof Element && listener[node.nodeName] instanceof Set && listener[node.nodeName].has(attr);\n}\n\nfunction verify(node, listener) {\n  const images = new Set();\n\n  if (isValidElem(listener, node)) {\n    listener[node.nodeName].forEach(attr => {\n      if (node.hasAttribute(attr)) {\n        images.add(node.getAttribute(attr));\n      }\n    });\n  }\n\n  return [...images];\n}\n\nclass ImageHistory {\n  constructor(root, targets, filter, defFilter = true) {\n    _root.set(this, void 0);\n\n    _listener.set(this, {});\n\n    _observer.set(this, void 0);\n\n    _mirroring.set(this, void 0);\n\n    _changed.set(this, new Map());\n\n    _rules.set(this, []);\n\n    __classPrivateFieldSet(this, _root, root);\n\n    if (targets && typeof targets === 'object') {\n      Object.keys(targets).forEach(nodeName => {\n        __classPrivateFieldGet(this, _listener)[nodeName.toUpperCase()] = new Set(targets[nodeName]);\n      });\n    }\n\n    if (__classPrivateFieldGet(this, _listener)['IMG']) {\n      __classPrivateFieldGet(this, _listener)['IMG'].add('src');\n    } else {\n      __classPrivateFieldGet(this, _listener)['IMG'] = new Set(['src']);\n    }\n\n    if (filter !== false && defFilter) {\n      __classPrivateFieldGet(this, _rules).push(function (value) {\n        return !/^(data:|blob:)/.test(value);\n      });\n    }\n\n    if (Array.isArray(filter)) {\n      __classPrivateFieldGet(this, _rules).push(...filter);\n    } else if (typeof filter === 'function') {\n      __classPrivateFieldGet(this, _rules).push(filter);\n    }\n\n    __classPrivateFieldSet(this, _mirroring, this.statistics());\n\n    __classPrivateFieldSet(this, _observer, new MutationObserver(mutations => {\n      mutations.forEach(record => {\n        if (record.type == 'childList') {\n          const {\n            addedNodes,\n            removedNodes\n          } = record;\n          removedNodes.forEach(node => {\n            verify(node, __classPrivateFieldGet(this, _listener)).forEach(img => {\n              if (this.valid(img)) {\n                __classPrivateFieldGet(this, _changed).set(img, false);\n              }\n            });\n          });\n          addedNodes.forEach(node => {\n            verify(node, __classPrivateFieldGet(this, _listener)).forEach(img => {\n              if (this.valid(img)) {\n                __classPrivateFieldGet(this, _changed).set(img, true);\n              }\n            });\n          });\n        } else {\n          const {\n            target,\n            oldValue,\n            attributeName\n          } = record;\n\n          if (isValidAttr(__classPrivateFieldGet(this, _listener), target, attributeName)) {\n            if (oldValue && this.valid(oldValue)) {\n              __classPrivateFieldGet(this, _changed).set(oldValue, false);\n            }\n\n            const attr = target.getAttribute(attributeName);\n\n            if (attr && this.valid(attr)) {\n              __classPrivateFieldGet(this, _changed).set(attr, true);\n            }\n          }\n        }\n      });\n    }));\n\n    __classPrivateFieldGet(this, _observer).observe(root, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeOldValue: true,\n      attributeFilter: attributeFilter(__classPrivateFieldGet(this, _listener))\n    });\n  }\n\n  get root() {\n    return __classPrivateFieldGet(this, _root);\n  }\n\n  get mirroring() {\n    return Object.assign({}, __classPrivateFieldGet(this, _mirroring));\n  }\n\n  get listener() {\n    const temp = {};\n    Object.entries(__classPrivateFieldGet(this, _listener)).forEach(([nodeName, attrs]) => {\n      temp[nodeName] = [...attrs];\n    });\n    return temp;\n  }\n\n  all() {\n    const old = __classPrivateFieldGet(this, _mirroring);\n\n    const now = this.statistics();\n    const temp = [];\n\n    __classPrivateFieldGet(this, _changed).forEach((status, img) => {\n      if (status && !old[img]) {\n        temp.push({\n          image: img,\n          type: 'inserted'\n        });\n      } else {\n        if (!now[img]) {\n          temp.push({\n            image: img,\n            type: 'deleted'\n          });\n        } else if (!old[img]) {\n          temp.push({\n            image: img,\n            type: 'inserted'\n          });\n        }\n      }\n    });\n\n    return temp;\n  }\n\n  inserted() {\n    return this.all().filter(row => row.type === 'inserted').map(row => row.image);\n  }\n\n  deleted() {\n    return this.all().filter(row => row.type === 'deleted').map(row => row.image);\n  }\n\n  statistics() {\n    const temp = {};\n    Object.keys(__classPrivateFieldGet(this, _listener)).forEach(nodeName => {\n      const nodes = Array.from(__classPrivateFieldGet(this, _root).querySelectorAll(nodeName));\n      nodes.forEach(el => {\n        __classPrivateFieldGet(this, _listener)[nodeName].forEach(attr => {\n          if (el.hasAttribute(attr)) {\n            const img = el.getAttribute(attr);\n\n            if (temp[img]) {\n              temp[img] += 1;\n            } else {\n              temp[img] = 1;\n            }\n          }\n        });\n      });\n    });\n    return temp;\n  }\n\n  rebuild() {\n    __classPrivateFieldSet(this, _mirroring, this.statistics());\n\n    this.clear();\n    return this.mirroring;\n  }\n\n  clear() {\n    __classPrivateFieldGet(this, _changed).clear();\n  }\n\n  destory() {\n    __classPrivateFieldGet(this, _observer).disconnect();\n\n    __classPrivateFieldGet(this, _changed).clear();\n\n    __classPrivateFieldSet(this, _listener, {});\n\n    __classPrivateFieldSet(this, _mirroring, {});\n  }\n\n  valid(img) {\n    for (let fn of __classPrivateFieldGet(this, _rules)) {\n      if (!fn(img)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexports.default = ImageHistory;\n_root = new WeakMap(), _listener = new WeakMap(), _observer = new WeakMap(), _mirroring = new WeakMap(), _changed = new WeakMap(), _rules = new WeakMap();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9JbWFnZUhpc3RvcnkvLi9zcmMvaW5kZXgudHM/ZmZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcm90ZWN0ZWQg5aqS5L2T5paH5Lu277yIaW1hZ2XvvInnm5HmjqdcbiAqL1xuXG4vKlxuMeOAgeWIneWni+WMluaXtuW7uueri+mVnOWDj++8jOS9nOS4uuWkmumikeasoemTvuaOpeaYr+WQpuS4uuWOn+Wni+mTvuaOpeeahOS+neaNrlxuMuOAgeaWsOWinueahOWkmumikeasoemTvuaOpeacquiiq+WIoOWwveaXtuS7jeiiq+iupOS4uuaYr+aWsOWinumTvuaOpVxuM+OAgemcgOimgeWMuuWIhumTvuaOpeS4uuaWsOWinuaIluWIoOmZpFxuM+OAgeaWsOWinueahOmTvuaOpeaYr+mVnOWDj+S4reWtmOWcqOeahOmTvuaOpeaXtu+8jOS4jeiiq+iupOWumuS4uuaWsOWinumTvuaOpVxuXG7lkI3or43op6Pph4rvvJpcbiAgICDlpJrpopHlm77niYfvvJrlkIzkuIDpk77mjqXlpJrmrKHlh7rnjrBcbiAgICDplZzlg4/mlbDmja7vvJrooqvnu5HlrprnmoTmoLnoioLngrnkuIvmn5DkuIDml7bliLvnmoTlm77niYfmlbDmja7jgILmr5TlpoLkuozmrKHnvJbovpHmlofnq6Dml7bpnIDopoHmnoTlu7rplZzlg4/mlbDmja7kvZzkuLrlkI7nu63lm77niYflop7lh4/nmoTkvp3mja7jgIJcbiovXG5cbnR5cGUgTGlzdGVuZXIgPSB7XG4gICAgW3Byb3BOYW1lOiBzdHJpbmddOiBTZXQ8c3RyaW5nPlxufVxuXG5leHBvcnQgdHlwZSBWYWxpZGF0b3IgPSAodmFsdWU6IHN0cmluZykgPT4gYm9vbGVhblxuXG5leHBvcnQgdHlwZSBUYXJnZXRzID0ge1xuICAgIFtwcm9wTmFtZTogc3RyaW5nXTogc3RyaW5nW11cbn1cblxuLyoqXG4gKiDnu5/orqHpk77mjqXlj4rlkIzkuIDkuKrpk77mjqXlh7rnjrDnmoTmrKHmlbBcbiAqL1xuZXhwb3J0IHR5cGUgTWlycm9yaW5nID0ge1xuICAgIFtwcm9wTmFtZTogc3RyaW5nXTogbnVtYmVyXG59XG5cbmZ1bmN0aW9uIGF0dHJpYnV0ZUZpbHRlcihsaXN0ZW5lcjogTGlzdGVuZXIpIHtcbiAgICBjb25zdCBmaWx0ZXI6IHN0cmluZ1tdID0gW11cbiAgICBPYmplY3QudmFsdWVzKGxpc3RlbmVyKS5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgIGZpbHRlci5wdXNoKC4uLnJvdylcbiAgICB9KVxuICAgIHJldHVybiBmaWx0ZXJcbn1cblxuLyoqXG4gKiDpqozor4HlvZPliY3oioLngrnmmK/lkKbkuLrmnInmlYjoioLngrlcbiAqIEBwYXJhbSBsaXN0ZW5lciDooqvnm5HlkKznmoToioLngrnnvJPlrZhcbiAqIEBwYXJhbSBub2RlIOiiq+mqjOivgeeahOiKgueCuVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbShsaXN0ZW5lcjogTGlzdGVuZXIsIG5vZGU6IE5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgbGlzdGVuZXJbbm9kZS5ub2RlTmFtZV0gaW5zdGFuY2VvZiBTZXRcbn1cblxuLyoqXG4gKiDpqozor4EgYXR0cmlidXRlIOWQjeaYr+WQpuacieaViFxuICogQHBhcmFtIG5vZGUg6KKr6aqM6K+B55qEIEVsZW1lbnQg6IqC54K5XG4gKiBAcGFyYW0gYXR0ciDooqvpqozor4HnmoQgYXR0cmlidXRlIOWQjVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXR0cihsaXN0ZW5lcjogTGlzdGVuZXIsIG5vZGU6IE5vZGUsIGF0dHI6IHN0cmluZyB8IG51bGwpIHtcbiAgICByZXR1cm4gYXR0ciAmJiBub2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiBsaXN0ZW5lcltub2RlLm5vZGVOYW1lXSBpbnN0YW5jZW9mIFNldCAmJiBsaXN0ZW5lcltub2RlLm5vZGVOYW1lXS5oYXMoYXR0cilcbn1cblxuZnVuY3Rpb24gdmVyaWZ5KG5vZGU6IE5vZGUsIGxpc3RlbmVyOiBMaXN0ZW5lcikge1xuICAgIGNvbnN0IGltYWdlczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KClcbiAgICBpZiAoaXNWYWxpZEVsZW0obGlzdGVuZXIsIG5vZGUpKSB7XG4gICAgICAgIGxpc3RlbmVyW25vZGUubm9kZU5hbWVdLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgICBpZiAoKG5vZGUgYXMgRWxlbWVudCkuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VzLmFkZCgobm9kZSBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoYXR0cikgYXMgc3RyaW5nKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gWy4uLmltYWdlc11cbn1cblxuLyoqXG4gKiDlm77niYfnmoTljoblj7LorrDlvZXvvIzpnIDopoHlnKggZWRpdG9yLmNyZWF0ZSDkuYvlkI7osIPnlKhcbiAqXG4gKiBlZ++8mmVkaXRvci5pbWdzID0gbmV3IEltYWdlSGlzdG9yeShlZGl0b3IuJHRleHRFbGVtLmVsZW1zWzBdKVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZUhpc3Rvcnkge1xuICAgICNyb290OiBFbGVtZW50XG5cbiAgICAvKipcbiAgICAgKiDpnIDopoHooqvnm5HlkKznmoToioLngrnnmoQgbm9kZU5hbWUg5Y+K5a+55bqU55qEIGF0dHJpYnV0ZSDlsZ7mgKflkI1cbiAgICAgKi9cbiAgICAjbGlzdGVuZXI6IExpc3RlbmVyID0ge31cblxuICAgIC8qKlxuICAgICAqIOebkeWQrOWZqFxuICAgICAqL1xuICAgICNvYnNlcnZlcjogTXV0YXRpb25PYnNlcnZlclxuXG4gICAgLyoqXG4gICAgICog5qC56IqC54K55LiL5p+Q5LiA5Yi755qE5Zu+54mH6ZWc5YOP5pWw5o2uXG4gICAgICovXG4gICAgI21pcnJvcmluZzogTWlycm9yaW5nXG5cbiAgICAvKipcbiAgICAgKiBpbWFnZSDmoIfnrb7nmoTlj5jljJborrDlvZXjgIJib29sZWFuIOWAvOihqOekuiBpbWFnZSDmoIfnrb7lvZPliY3nmoTnirbmgIHvvIzkuLogdHJ1ZSDooajnpLrlrZjlnKjkuo7mlofmoaPkuK3vvJvkuLogZmFsc2Ug6KGo56S66K+lIGltYWdlIOagh+etvuiiq+WIoOmZpOOAglxuICAgICAqL1xuICAgICNjaGFuZ2VkOiBNYXA8c3RyaW5nLCBib29sZWFuPiA9IG5ldyBNYXAoKVxuXG4gICAgLyoqXG4gICAgICog5Zu+54mH6ZO+5o6l55qE6aqM6K+B6KeE5YiZXG4gICAgICpcbiAgICAgKi9cbiAgICAjcnVsZXM6IFZhbGlkYXRvcltdID0gW11cblxuICAgIC8qKlxuICAgICAqIOW9k+WJjeWunuS+i+ebkeWQrOeahOagueiKgueCuVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Jvb3RcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlvZPliY3lrp7kvovnmoTlm77niYfplZzlg4/mlbDmja5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1pcnJvcmluZygpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4udGhpcy4jbWlycm9yaW5nIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnm5HlkKznmoToioLngrnnsbvlnovlj4ror6XoioLngrnlr7nlupTnm5HlkKznmoQgYXR0cmlidXRlIOWQjVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbGlzdGVuZXIoKSB7XG4gICAgICAgIGNvbnN0IHRlbXA6IHsgW3Byb3BOYW1lOiBzdHJpbmddOiBzdHJpbmdbXSB9ID0ge31cbiAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy4jbGlzdGVuZXIpLmZvckVhY2goKFtub2RlTmFtZSwgYXR0cnNdKSA9PiB7XG4gICAgICAgICAgICB0ZW1wW25vZGVOYW1lXSA9IFsuLi5hdHRyc11cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRlbXBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcm9vdCDooqvnm5HlkKznmoQgRWxlbWVudCDoioLngrnvvIzov5nph4zmjIcgd2FuZ0VkaXRvciDnmoTnvJbovpHljLrmoLnoioLngrlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihyb290OiBFbGVtZW50LCB0YXJnZXRzPzogVGFyZ2V0cywgZmlsdGVyPzogVmFsaWRhdG9yIHwgVmFsaWRhdG9yW10gfCBmYWxzZSwgZGVmRmlsdGVyOiBib29sZWFuID0gdHJ1ZSkge1xuICAgICAgICAvLyDooqvnm5HlkKznmoTmoLnoioLngrlcbiAgICAgICAgdGhpcy4jcm9vdCA9IHJvb3RcblxuICAgICAgICAvLyDliJ3lp4vljJbpnIDopoHooqvnm5HlkKznmoToioLngrnnmoQgbm9kZU5hbWUg5Y+K5a+55bqU55qEIGF0dHJpYnV0ZSDlsZ7mgKflkI1cbiAgICAgICAgaWYgKHRhcmdldHMgJiYgdHlwZW9mIHRhcmdldHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0YXJnZXRzKS5mb3JFYWNoKG5vZGVOYW1lID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNsaXN0ZW5lcltub2RlTmFtZS50b1VwcGVyQ2FzZSgpXSA9IG5ldyBTZXQodGFyZ2V0c1tub2RlTmFtZV0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIC8vIOa3u+WKoOm7mOiupOebkeWQrCBpbWcg55qEICBzcmMgYXR0cmlidXRlXG4gICAgICAgIGlmICh0aGlzLiNsaXN0ZW5lclsnSU1HJ10pIHtcbiAgICAgICAgICAgIHRoaXMuI2xpc3RlbmVyWydJTUcnXS5hZGQoJ3NyYycpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNsaXN0ZW5lclsnSU1HJ10gPSBuZXcgU2V0KFsnc3JjJ10pXG4gICAgICAgIH1cblxuICAgICAgICAvLyDliJ3lp4vljJbov4fmu6Top4TliJlcbiAgICAgICAgLy8g5YaF572u6KeE5YiZ77yI6Z2eIGJhc2U2NC9VUkwuY3JlYXRlT2JqZWN0VVJMIOWbvueJh+mTvuaOpe+8iVxuICAgICAgICBpZiAoZmlsdGVyICE9PSBmYWxzZSAmJiBkZWZGaWx0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuI3J1bGVzLnB1c2goZnVuY3Rpb24gKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIS9eKGRhdGE6fGJsb2I6KS8udGVzdCh2YWx1ZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgLy8g55So5oi36Ieq5a6a5LmJ6KeE5YiZXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcbiAgICAgICAgICAgIHRoaXMuI3J1bGVzLnB1c2goLi4uZmlsdGVyKVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuI3J1bGVzLnB1c2goZmlsdGVyKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4jbWlycm9yaW5nID0gdGhpcy5zdGF0aXN0aWNzKClcblxuICAgICAgICAvLyDliJ3lp4vljJbnm5HlkKzlmahcbiAgICAgICAgdGhpcy4jb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgbXV0YXRpb25zLmZvckVhY2gocmVjb3JkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhZGRlZE5vZGVzLCByZW1vdmVkTm9kZXMgfSA9IHJlY29yZFxuXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZ5KG5vZGUsIHRoaXMuI2xpc3RlbmVyKS5mb3JFYWNoKGltZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWQoaW1nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNjaGFuZ2VkLnNldChpbWcsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgYWRkZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZ5KG5vZGUsIHRoaXMuI2xpc3RlbmVyKS5mb3JFYWNoKGltZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWQoaW1nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNjaGFuZ2VkLnNldChpbWcsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRhcmdldCwgb2xkVmFsdWUsIGF0dHJpYnV0ZU5hbWUgfSA9IHJlY29yZFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZEF0dHIodGhpcy4jbGlzdGVuZXIsIHRhcmdldCwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAmJiB0aGlzLnZhbGlkKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2NoYW5nZWQuc2V0KG9sZFZhbHVlIGFzIHN0cmluZywgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyID0gKHRhcmdldCBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSBhcyBzdHJpbmcpIGFzIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIgJiYgdGhpcy52YWxpZChhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2NoYW5nZWQuc2V0KGF0dHIsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIOe7keWumuebkeWQrFxuICAgICAgICB0aGlzLiNvYnNlcnZlci5vYnNlcnZlKHJvb3QsIHtcbiAgICAgICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IGF0dHJpYnV0ZUZpbHRlcih0aGlzLiNsaXN0ZW5lciksXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6L+U5Zue5omA5pyJ55qE5Y6G5Y+y6K6w5b2V5L+h5oGvXG4gICAgICovXG4gICAgcHVibGljIGFsbCgpIHtcbiAgICAgICAgLy8g6ZWc5YOP5Zu+54mHXG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuI21pcnJvcmluZ1xuXG4gICAgICAgIC8vIOe7n+iuoeW9k+WJjeeahOWbvueJh1xuICAgICAgICBjb25zdCBub3cgPSB0aGlzLnN0YXRpc3RpY3MoKVxuXG4gICAgICAgIC8vIOeUn+aIkOaJgOacieeahOWbvueJh+WOhuWPsuiusOW9leS/oeaBr1xuICAgICAgICBjb25zdCB0ZW1wOiB7IGltYWdlOiBzdHJpbmc7IHR5cGU6ICdpbnNlcnRlZCcgfCAnZGVsZXRlZCcgfVtdID0gW11cbiAgICAgICAgdGhpcy4jY2hhbmdlZC5mb3JFYWNoKChzdGF0dXMsIGltZykgPT4ge1xuICAgICAgICAgICAgLy8g5paw5re75Yqg55qE5Zu+54mHICYmIOmdnumVnOWDj+S4reeahOWbvueJh1xuICAgICAgICAgICAgaWYgKHN0YXR1cyAmJiAhb2xkW2ltZ10pIHtcbiAgICAgICAgICAgICAgICB0ZW1wLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5zZXJ0ZWQnLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDooqvliKDpmaTnmoTlm77niYdcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIOivpeWbvueJh+iiq+WIoOWwvVxuICAgICAgICAgICAgICAgIGlmICghbm93W2ltZ10pIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGVsZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghb2xkW2ltZ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5Zu+54mH5pyq6KKr5Yig5bC977yI5aSa6aKR5Zu+54mH77yJICYmIOmdnumVnOWDj+S4reeahOWbvueJh1xuICAgICAgICAgICAgICAgICAgICB0ZW1wLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnNlcnRlZCcsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdGVtcFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaWsOWinuWbvueJh+mTvuaOpeeahOaVsOe7hOmbhuWQiFxuICAgICAqL1xuICAgIHB1YmxpYyBpbnNlcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsKClcbiAgICAgICAgICAgIC5maWx0ZXIocm93ID0+IHJvdy50eXBlID09PSAnaW5zZXJ0ZWQnKVxuICAgICAgICAgICAgLm1hcChyb3cgPT4gcm93LmltYWdlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiiq+WIoOmZpOWbvueJh+mTvuaOpeeahOaVsOe7hOmbhuWQiFxuICAgICAqL1xuICAgIHB1YmxpYyBkZWxldGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGwoKVxuICAgICAgICAgICAgLmZpbHRlcihyb3cgPT4gcm93LnR5cGUgPT09ICdkZWxldGVkJylcbiAgICAgICAgICAgIC5tYXAocm93ID0+IHJvdy5pbWFnZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnu5/orqHlvZPliY3nmoTlm77niYfpk77mjqXku6Xlj4rlr7nlupTnmoTpk77mjqXmrKHmlbBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGlzdGljcygpIHtcbiAgICAgICAgY29uc3QgdGVtcDogTWlycm9yaW5nID0ge31cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy4jbGlzdGVuZXIpLmZvckVhY2gobm9kZU5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBBcnJheS5mcm9tKHRoaXMuI3Jvb3QucXVlcnlTZWxlY3RvckFsbChub2RlTmFtZSkpXG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNsaXN0ZW5lcltub2RlTmFtZV0uZm9yRWFjaChhdHRyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nID0gZWwuZ2V0QXR0cmlidXRlKGF0dHIpIGFzIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBbaW1nXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBbaW1nXSArPSAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBbaW1nXSA9IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdGVtcFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOmHjeaWsOaehOW7uumVnOWDj+aVsOaNru+8iOWwhuatpOWIu+eahOWbvueJh+aVsOaNruS9nOS4uuWQjue7reeahOWIpOaWreS+neaNru+8jOS4lOabvue7j+eahOWOhuWPsuiusOW9leWwhuiiq+a4hemZpO+8iVxuICAgICAqL1xuICAgIHB1YmxpYyByZWJ1aWxkKCkge1xuICAgICAgICB0aGlzLiNtaXJyb3JpbmcgPSB0aGlzLnN0YXRpc3RpY3MoKVxuICAgICAgICB0aGlzLmNsZWFyKClcbiAgICAgICAgcmV0dXJuIHRoaXMubWlycm9yaW5nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5riF6Zmk5omA5pyJ55qE5Y6G5Y+y6K6w5b2VXG4gICAgICovXG4gICAgcHVibGljIGNsZWFyKCkge1xuICAgICAgICB0aGlzLiNjaGFuZ2VkLmNsZWFyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDplIDmr4Hnm5HlkKzlmahcbiAgICAgKi9cbiAgICBwdWJsaWMgZGVzdG9yeSgpIHtcbiAgICAgICAgdGhpcy4jb2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgICAgIHRoaXMuI2NoYW5nZWQuY2xlYXIoKVxuICAgICAgICB0aGlzLiNsaXN0ZW5lciA9IHt9XG4gICAgICAgIHRoaXMuI21pcnJvcmluZyA9IHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6aqM6K+B6ZO+5o6l5piv5ZCm56ym5ZCI6KeE6IyDXG4gICAgICogQHBhcmFtIGltZyDlm77niYfpk77mjqVcbiAgICAgKi9cbiAgICBwdWJsaWMgdmFsaWQoaW1nOiBzdHJpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgZm4gb2YgdGhpcy4jcnVsZXMpIHtcbiAgICAgICAgICAgIGlmICghZm4oaW1nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBeURBO0FBeERBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBS0E7QUFDQTtBQStCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBdkdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0ZBO0FBRUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQS9QQTtBQUNBO0FBREE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ })

/******/ })["default"];
});