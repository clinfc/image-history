(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ImageHistory"] = factory();
	else
		root["ImageHistory"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n\n  privateMap.set(receiver, value);\n  return value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n};\n\nvar _root, _listener, _observer, _primordial, _changed, _rules;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction attributeFilter(listener) {\n  const filter = [];\n  Object.values(listener).forEach(row => {\n    filter.push(...row);\n  });\n  return filter;\n}\n\nfunction initConfig(listener) {\n  return {\n    subtree: true,\n    childList: true,\n    attributes: true,\n    attributeOldValue: true,\n    attributeFilter: attributeFilter(listener)\n  };\n}\n\nfunction isValidElem(listener, node) {\n  return node instanceof Element && listener[node.nodeName] instanceof Set;\n}\n\nfunction isValidAttr(listener, node, attr) {\n  return attr && node instanceof Element && listener[node.nodeName] instanceof Set && listener[node.nodeName].has(attr);\n}\n\nfunction verify(node, listener, changed, value) {\n  const images = new Set();\n\n  if (isValidElem(listener, node)) {\n    listener[node.nodeName].forEach(attr => {\n      if (node.hasAttribute(attr)) {\n        images.add(node.getAttribute(attr));\n      }\n    });\n  }\n\n  return [...images];\n}\n\nfunction statistics(root, listener) {\n  const temp = {};\n  Object.keys(listener).forEach(nodeName => {\n    const nodes = Array.from(root.querySelectorAll(nodeName));\n    nodes.forEach(el => {\n      listener[nodeName].forEach(attr => {\n        if (el.hasAttribute(attr)) {\n          const img = el.getAttribute(attr);\n\n          if (temp[img]) {\n            temp[img] += 1;\n          } else {\n            temp[img] = 1;\n          }\n        }\n      });\n    });\n  });\n  return temp;\n}\n\nclass ImageHistory {\n  constructor(root, targets, filter, defFilter = true) {\n    _root.set(this, void 0);\n\n    _listener.set(this, {});\n\n    _observer.set(this, void 0);\n\n    _primordial.set(this, void 0);\n\n    _changed.set(this, new Map());\n\n    _rules.set(this, []);\n\n    __classPrivateFieldSet(this, _root, root);\n\n    if (targets && typeof targets === 'object') {\n      Object.keys(targets).forEach(nodeName => {\n        __classPrivateFieldGet(this, _listener)[nodeName.toUpperCase()] = new Set(targets[nodeName]);\n      });\n    }\n\n    if (__classPrivateFieldGet(this, _listener)['IMG']) {\n      __classPrivateFieldGet(this, _listener)['IMG'].add('src');\n    } else {\n      __classPrivateFieldGet(this, _listener)['IMG'] = new Set(['src']);\n    }\n\n    if (filter !== false && defFilter) {\n      __classPrivateFieldGet(this, _rules).push(function (value) {\n        return !/^(blob:.+;base64:|data:)/.test(value);\n      });\n    }\n\n    if (Array.isArray(filter)) {\n      __classPrivateFieldGet(this, _rules).push(...filter);\n    } else if (typeof filter === 'function') {\n      __classPrivateFieldGet(this, _rules).push(filter);\n    }\n\n    __classPrivateFieldSet(this, _primordial, statistics(__classPrivateFieldGet(this, _root), __classPrivateFieldGet(this, _listener)));\n\n    __classPrivateFieldSet(this, _observer, new MutationObserver(mutations => {\n      mutations.forEach(record => {\n        if (record.type == 'childList') {\n          const {\n            addedNodes,\n            removedNodes\n          } = record;\n          removedNodes.forEach(node => {\n            verify(node, __classPrivateFieldGet(this, _listener)).forEach(img => {\n              if (this.valid(img)) {\n                __classPrivateFieldGet(this, _changed).set(img, false);\n              }\n            });\n          });\n          addedNodes.forEach(node => {\n            verify(node, __classPrivateFieldGet(this, _listener)).forEach(img => {\n              if (this.valid(img)) {\n                __classPrivateFieldGet(this, _changed).set(img, true);\n              }\n            });\n          });\n        } else {\n          const {\n            target,\n            oldValue,\n            attributeName\n          } = record;\n\n          if (isValidAttr(__classPrivateFieldGet(this, _listener), target, attributeName)) {\n            if (oldValue && this.valid(oldValue)) {\n              __classPrivateFieldGet(this, _changed).set(oldValue, false);\n            }\n\n            const attr = target.getAttribute(attributeName);\n\n            if (attr && this.valid(attr)) {\n              __classPrivateFieldGet(this, _changed).set(attr, true);\n            }\n          }\n        }\n      });\n    }));\n\n    __classPrivateFieldGet(this, _observer).observe(root, initConfig(__classPrivateFieldGet(this, _listener)));\n  }\n\n  get root() {\n    return __classPrivateFieldGet(this, _root);\n  }\n\n  get listener() {\n    const temp = {};\n    Object.entries(__classPrivateFieldGet(this, _listener)).forEach(([nodeName, attrs]) => {\n      temp[nodeName] = [...attrs];\n    });\n    return temp;\n  }\n\n  get primordial() {\n    return Object.entries(__classPrivateFieldGet(this, _primordial));\n  }\n\n  statistics() {\n    return Object.entries(statistics(__classPrivateFieldGet(this, _root), __classPrivateFieldGet(this, _listener)));\n  }\n\n  deleted() {\n    return this.all().filter(row => row.type === 'deleted').map(row => row.image);\n  }\n\n  inserted() {\n    return this.all().filter(row => row.type === 'inserted').map(row => row.image);\n  }\n\n  all() {\n    const now = statistics(__classPrivateFieldGet(this, _root), __classPrivateFieldGet(this, _listener));\n    const deleted = Object.keys(__classPrivateFieldGet(this, _primordial)).filter(img => !now[img]);\n    const temp = [];\n\n    __classPrivateFieldGet(this, _changed).forEach((status, img) => {\n      if (!__classPrivateFieldGet(this, _primordial)[img] || deleted.includes(img)) {\n        temp.push({\n          image: img,\n          type: status ? 'inserted' : 'deleted'\n        });\n      }\n    });\n\n    return temp;\n  }\n\n  clear() {\n    __classPrivateFieldGet(this, _changed).clear();\n  }\n\n  destory() {\n    __classPrivateFieldGet(this, _observer).disconnect();\n\n    __classPrivateFieldGet(this, _changed).clear();\n\n    __classPrivateFieldSet(this, _listener, {});\n\n    __classPrivateFieldSet(this, _primordial, {});\n  }\n\n  valid(img) {\n    return __classPrivateFieldGet(this, _rules).reduce((ar, fn) => ar && fn(img), true);\n  }\n\n}\n\nexports.default = ImageHistory;\n_root = new WeakMap(), _listener = new WeakMap(), _observer = new WeakMap(), _primordial = new WeakMap(), _changed = new WeakMap(), _rules = new WeakMap();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9JbWFnZUhpc3RvcnkvLi9zcmMvaW5kZXgudHM/ZmZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcm90ZWN0ZWQg5aqS5L2T5paH5Lu277yIaW1hZ2XvvInnm5HmjqdcbiAqL1xuXG50eXBlIExpc3RlbmVyID0ge1xuICAgIFtwcm9wTmFtZTogc3RyaW5nXTogU2V0PHN0cmluZz5cbn1cblxuZXhwb3J0IHR5cGUgVmFsaWRhdG9yID0gKHZhbHVlOiBzdHJpbmcpID0+IGJvb2xlYW5cblxuZXhwb3J0IHR5cGUgVGFyZ2V0cyA9IHtcbiAgICBbcHJvcE5hbWU6IHN0cmluZ106IHN0cmluZ1tdXG59XG5cbi8qKlxuICog57uf6K6h6ZO+5o6l5Y+K5ZCM5LiA5Liq6ZO+5o6l5Ye6546w55qE5qyh5pWwXG4gKi9cbmV4cG9ydCB0eXBlIFN0YXRpc3RpY3MgPSB7XG4gICAgW3Byb3BOYW1lOiBzdHJpbmddOiBudW1iZXJcbn1cblxuZnVuY3Rpb24gYXR0cmlidXRlRmlsdGVyKGxpc3RlbmVyOiBMaXN0ZW5lcikge1xuICAgIGNvbnN0IGZpbHRlcjogc3RyaW5nW10gPSBbXVxuICAgIE9iamVjdC52YWx1ZXMobGlzdGVuZXIpLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgZmlsdGVyLnB1c2goLi4ucm93KVxuICAgIH0pXG4gICAgcmV0dXJuIGZpbHRlclxufVxuXG5mdW5jdGlvbiBpbml0Q29uZmlnKGxpc3RlbmVyOiBMaXN0ZW5lcik6IE11dGF0aW9uT2JzZXJ2ZXJJbml0IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IGF0dHJpYnV0ZUZpbHRlcihsaXN0ZW5lciksXG4gICAgfVxufVxuXG4vKipcbiAqIOmqjOivgeW9k+WJjeiKgueCueaYr+WQpuS4uuacieaViOiKgueCuVxuICogQHBhcmFtIGxpc3RlbmVyIOiiq+ebkeWQrOeahOiKgueCuee8k+WtmFxuICogQHBhcmFtIG5vZGUg6KKr6aqM6K+B55qE6IqC54K5XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtKGxpc3RlbmVyOiBMaXN0ZW5lciwgbm9kZTogTm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiBsaXN0ZW5lcltub2RlLm5vZGVOYW1lXSBpbnN0YW5jZW9mIFNldFxufVxuXG4vKipcbiAqIOmqjOivgSBhdHRyaWJ1dGUg5ZCN5piv5ZCm5pyJ5pWIXG4gKiBAcGFyYW0gbm9kZSDooqvpqozor4HnmoQgRWxlbWVudCDoioLngrlcbiAqIEBwYXJhbSBhdHRyIOiiq+mqjOivgeeahCBhdHRyaWJ1dGUg5ZCNXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBdHRyKGxpc3RlbmVyOiBMaXN0ZW5lciwgbm9kZTogTm9kZSwgYXR0cjogc3RyaW5nIHwgbnVsbCkge1xuICAgIHJldHVybiBhdHRyICYmIG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGxpc3RlbmVyW25vZGUubm9kZU5hbWVdIGluc3RhbmNlb2YgU2V0ICYmIGxpc3RlbmVyW25vZGUubm9kZU5hbWVdLmhhcyhhdHRyKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnkobm9kZTogTm9kZSwgbGlzdGVuZXI6IExpc3RlbmVyLCBjaGFuZ2VkPzogTWFwPHN0cmluZywgYm9vbGVhbj4sIHZhbHVlPzogYm9vbGVhbikge1xuICAgIGNvbnN0IGltYWdlczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KClcbiAgICBpZiAoaXNWYWxpZEVsZW0obGlzdGVuZXIsIG5vZGUpKSB7XG4gICAgICAgIGxpc3RlbmVyW25vZGUubm9kZU5hbWVdLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgICBpZiAoKG5vZGUgYXMgRWxlbWVudCkuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlZC5zZXQoKG5vZGUgYXMgRWxlbWVudCkuZ2V0QXR0cmlidXRlKGF0dHIpIGFzIHN0cmluZywgdmFsdWUpXG4gICAgICAgICAgICAgICAgaW1hZ2VzLmFkZCgobm9kZSBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoYXR0cikgYXMgc3RyaW5nKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gWy4uLmltYWdlc11cbn1cblxuLyoqXG4gKiDnu5/orqHpk77mjqXlj4rlkIzkuIDkuKrpk77mjqXlh7rnjrDnmoTmrKHmlbBcbiAqIEBwYXJhbSByb290IOagueiKgueCuVxuICogQHBhcmFtIGxpc3RlbmVyIOebkeWQrOeahOWxnuaAp1xuICovXG5mdW5jdGlvbiBzdGF0aXN0aWNzKHJvb3Q6IEVsZW1lbnQsIGxpc3RlbmVyOiBMaXN0ZW5lcikge1xuICAgIGNvbnN0IHRlbXA6IFN0YXRpc3RpY3MgPSB7fVxuICAgIE9iamVjdC5rZXlzKGxpc3RlbmVyKS5mb3JFYWNoKG5vZGVOYW1lID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBBcnJheS5mcm9tKHJvb3QucXVlcnlTZWxlY3RvckFsbChub2RlTmFtZSkpXG4gICAgICAgIG5vZGVzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJbbm9kZU5hbWVdLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWcgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cikgYXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wW2ltZ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBbaW1nXSArPSAxXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wW2ltZ10gPSAxXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH0pXG4gICAgcmV0dXJuIHRlbXBcbn1cblxuLyoqXG4gKiDlm77niYfnmoTljoblj7LorrDlvZXvvIzpnIDopoHlnKggZWRpdG9yLmNyZWF0ZSDkuYvlkI7osIPnlKhcbiAqXG4gKiBlZ++8mmVkaXRvci5pbWdzID0gbmV3IEltYWdlSGlzdG9yeShlZGl0b3IuJHRleHRFbGVtLmVsZW1zWzBdKVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZUhpc3Rvcnkge1xuICAgICNyb290OiBFbGVtZW50XG5cbiAgICAvKipcbiAgICAgKiDpnIDopoHooqvnm5HlkKznmoToioLngrnnmoQgbm9kZU5hbWUg5Y+K5a+55bqU55qEIGF0dHJpYnV0ZSDlsZ7mgKflkI1cbiAgICAgKi9cbiAgICAjbGlzdGVuZXI6IExpc3RlbmVyID0ge31cblxuICAgIC8qKlxuICAgICAqIOebkeWQrOWZqFxuICAgICAqL1xuICAgICNvYnNlcnZlcjogTXV0YXRpb25PYnNlcnZlclxuXG4gICAgLyoqXG4gICAgICog6K6w5b2V5Y6f5aeL5Zu+54mHXG4gICAgICovXG4gICAgI3ByaW1vcmRpYWw6IFN0YXRpc3RpY3NcblxuICAgIC8qKlxuICAgICAqIGltYWdlIOagh+etvueahOWPmOWMluiusOW9leOAgmJvb2xlYW4g5YC86KGo56S6IGltYWdlIOagh+etvuW9k+WJjeeahOeKtuaAge+8jOS4uiB0cnVlIOihqOekuuWtmOWcqOS6juaWh+aho+S4re+8m+S4uiBmYWxzZSDooajnpLror6UgaW1hZ2Ug5qCH562+6KKr5Yig6Zmk44CCXG4gICAgICovXG4gICAgI2NoYW5nZWQ6IE1hcDxzdHJpbmcsIGJvb2xlYW4+ID0gbmV3IE1hcCgpXG5cbiAgICAvKipcbiAgICAgKiDlm77niYfpk77mjqXnmoTpqozor4Hop4TliJlcbiAgICAgKlxuICAgICAqL1xuICAgICNydWxlczogVmFsaWRhdG9yW10gPSBbXVxuXG4gICAgLyoqXG4gICAgICog5b2T5YmN5a6e5L6L55uR5ZCs55qE5qC56IqC54K5XG4gICAgICovXG4gICAgcHVibGljIGdldCByb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcm9vdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOebkeWQrOeahOiKgueCueexu+Wei+WPiuivpeiKgueCueWvueW6lOebkeWQrOeahCBhdHRyaWJ1dGUg5ZCNXG4gICAgICovXG4gICAgcHVibGljIGdldCBsaXN0ZW5lcigpIHtcbiAgICAgICAgY29uc3QgdGVtcDogeyBbcHJvcE5hbWU6IHN0cmluZ106IHN0cmluZ1tdIH0gPSB7fVxuICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLiNsaXN0ZW5lcikuZm9yRWFjaCgoW25vZGVOYW1lLCBhdHRyc10pID0+IHtcbiAgICAgICAgICAgIHRlbXBbbm9kZU5hbWVdID0gWy4uLmF0dHJzXVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdGVtcFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOe7n+iuoeWIneWni+WMluaXtuWwseWtmOWcqOeahOWbvueJh+mTvuaOpeS7peWPiuWvueW6lOeahOasoeaVsFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcHJpbW9yZGlhbCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMuI3ByaW1vcmRpYWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHJvb3Qg6KKr55uR5ZCs55qEIEVsZW1lbnQg6IqC54K577yM6L+Z6YeM5oyHIHdhbmdFZGl0b3Ig55qE57yW6L6R5Yy65qC56IqC54K5XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm9vdDogRWxlbWVudCwgdGFyZ2V0cz86IFRhcmdldHMsIGZpbHRlcj86IFZhbGlkYXRvciB8IFZhbGlkYXRvcltdIHwgZmFsc2UsIGRlZkZpbHRlcjogYm9vbGVhbiA9IHRydWUpIHtcbiAgICAgICAgLy8g6KKr55uR5ZCs55qE5qC56IqC54K5XG4gICAgICAgIHRoaXMuI3Jvb3QgPSByb290XG5cbiAgICAgICAgLy8g5Yid5aeL5YyW6ZyA6KaB6KKr55uR5ZCs55qE6IqC54K555qEIG5vZGVOYW1lIOWPiuWvueW6lOeahCBhdHRyaWJ1dGUg5bGe5oCn5ZCNXG4gICAgICAgIGlmICh0YXJnZXRzICYmIHR5cGVvZiB0YXJnZXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGFyZ2V0cykuZm9yRWFjaChub2RlTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbGlzdGVuZXJbbm9kZU5hbWUudG9VcHBlckNhc2UoKV0gPSBuZXcgU2V0KHRhcmdldHNbbm9kZU5hbWVdKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICAvLyDmt7vliqDpu5jorqTnm5HlkKwgaW1nIOeahCAgc3JjIGF0dHJpYnV0ZVxuICAgICAgICBpZiAodGhpcy4jbGlzdGVuZXJbJ0lNRyddKSB7XG4gICAgICAgICAgICB0aGlzLiNsaXN0ZW5lclsnSU1HJ10uYWRkKCdzcmMnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jbGlzdGVuZXJbJ0lNRyddID0gbmV3IFNldChbJ3NyYyddKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5Yid5aeL5YyW6L+H5ruk6KeE5YiZXG4gICAgICAgIC8vIOWGhee9ruinhOWIme+8iOmdniBiYXNlNjQvVVJMLmNyZWF0ZU9iamVjdFVSTCDlm77niYfpk77mjqXvvIlcbiAgICAgICAgaWYgKGZpbHRlciAhPT0gZmFsc2UgJiYgZGVmRmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLiNydWxlcy5wdXNoKGZ1bmN0aW9uICh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEvXihibG9iOi4rO2Jhc2U2NDp8ZGF0YTopLy50ZXN0KHZhbHVlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICAvLyDnlKjmiLfoh6rlrprkuYnop4TliJlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyKSkge1xuICAgICAgICAgICAgdGhpcy4jcnVsZXMucHVzaCguLi5maWx0ZXIpXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy4jcnVsZXMucHVzaChmaWx0ZXIpXG4gICAgICAgIH1cblxuICAgICAgICAvLyDorrDlvZXlvZPliY3lt7LlrZjlnKjnmoTlm77niYfpk77mjqXku6Xlj4rlkIzkuIDpk77mjqXlh7rnjrDnmoTmrKHmlbBcbiAgICAgICAgdGhpcy4jcHJpbW9yZGlhbCA9IHN0YXRpc3RpY3ModGhpcy4jcm9vdCwgdGhpcy4jbGlzdGVuZXIpXG5cbiAgICAgICAgLy8g5Yid5aeL5YyW55uR5ZCs5ZmoXG4gICAgICAgIHRoaXMuI29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKHJlY29yZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzIH0gPSByZWNvcmRcblxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcmlmeShub2RlLCB0aGlzLiNsaXN0ZW5lcikuZm9yRWFjaChpbWcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKGltZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jY2hhbmdlZC5zZXQoaW1nLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcmlmeShub2RlLCB0aGlzLiNsaXN0ZW5lcikuZm9yRWFjaChpbWcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKGltZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jY2hhbmdlZC5zZXQoaW1nLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0YXJnZXQsIG9sZFZhbHVlLCBhdHRyaWJ1dGVOYW1lIH0gPSByZWNvcmRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRBdHRyKHRoaXMuI2xpc3RlbmVyLCB0YXJnZXQsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUgJiYgdGhpcy52YWxpZChvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNjaGFuZ2VkLnNldChvbGRWYWx1ZSBhcyBzdHJpbmcsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9ICh0YXJnZXQgYXMgRWxlbWVudCkuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUgYXMgc3RyaW5nKSBhcyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyICYmIHRoaXMudmFsaWQoYXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNjaGFuZ2VkLnNldChhdHRyLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuICAgICAgICAvLyDnu5Hlrprnm5HlkKxcbiAgICAgICAgdGhpcy4jb2JzZXJ2ZXIub2JzZXJ2ZShyb290LCBpbml0Q29uZmlnKHRoaXMuI2xpc3RlbmVyKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnu5/orqHlvZPliY3nmoTlm77niYfpk77mjqXku6Xlj4rlr7nlupTnmoTpk77mjqXmrKHmlbBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGlzdGljcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHN0YXRpc3RpY3ModGhpcy4jcm9vdCwgdGhpcy4jbGlzdGVuZXIpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiiq+WIoOmZpOWbvueJh+mTvuaOpeeahOaVsOe7hOmbhuWQiFxuICAgICAqL1xuICAgIHB1YmxpYyBkZWxldGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGwoKVxuICAgICAgICAgICAgLmZpbHRlcihyb3cgPT4gcm93LnR5cGUgPT09ICdkZWxldGVkJylcbiAgICAgICAgICAgIC5tYXAocm93ID0+IHJvdy5pbWFnZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlrDlop7lm77niYfpk77mjqXnmoTmlbDnu4Tpm4blkIhcbiAgICAgKi9cbiAgICBwdWJsaWMgaW5zZXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbCgpXG4gICAgICAgICAgICAuZmlsdGVyKHJvdyA9PiByb3cudHlwZSA9PT0gJ2luc2VydGVkJylcbiAgICAgICAgICAgIC5tYXAocm93ID0+IHJvdy5pbWFnZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDov5Tlm57miYDmnInnmoTljoblj7LorrDlvZXkv6Hmga9cbiAgICAgKi9cbiAgICBwdWJsaWMgYWxsKCkge1xuICAgICAgICAvLyDnu5/orqHlvZPliY3nmoTlm77niYfpk77mjqXmlbDmja5cbiAgICAgICAgY29uc3Qgbm93ID0gc3RhdGlzdGljcyh0aGlzLiNyb290LCB0aGlzLiNsaXN0ZW5lcilcbiAgICAgICAgLy8g57uf6K6h5ZCM5LiA5byg5Zu+54mH6ZO+5o6l6KKr5YWo6YOo5Yig6Zmk55qE5Y6f5aeL5Zu+54mHXG4gICAgICAgIGNvbnN0IGRlbGV0ZWQgPSBPYmplY3Qua2V5cyh0aGlzLiNwcmltb3JkaWFsKS5maWx0ZXIoaW1nID0+ICFub3dbaW1nXSlcbiAgICAgICAgLy8g55Sf5oiQ5omA5pyJ55qE5Zu+54mH5Y6G5Y+y6K6w5b2V5L+h5oGvXG4gICAgICAgIGNvbnN0IHRlbXA6IHsgaW1hZ2U6IHN0cmluZzsgdHlwZTogJ2luc2VydGVkJyB8ICdkZWxldGVkJyB9W10gPSBbXVxuICAgICAgICB0aGlzLiNjaGFuZ2VkLmZvckVhY2goKHN0YXR1cywgaW1nKSA9PiB7XG4gICAgICAgICAgICAvLyDpnZ7ljp/lp4vlm77niYcgfHwg5piv5Y6f5aeL5Zu+54mH77yM5L2G5piv5YWo6YOo6KKr5Yig6Zmk5LqGXG4gICAgICAgICAgICBpZiAoIXRoaXMuI3ByaW1vcmRpYWxbaW1nXSB8fCBkZWxldGVkLmluY2x1ZGVzKGltZykpIHtcbiAgICAgICAgICAgICAgICB0ZW1wLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBzdGF0dXMgPyAnaW5zZXJ0ZWQnIDogJ2RlbGV0ZWQnLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB0ZW1wXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5riF6Zmk5omA5pyJ55qE5Y6G5Y+y6K6w5b2VXG4gICAgICovXG4gICAgcHVibGljIGNsZWFyKCkge1xuICAgICAgICB0aGlzLiNjaGFuZ2VkLmNsZWFyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDplIDmr4Hnm5HlkKzlmahcbiAgICAgKi9cbiAgICBwdWJsaWMgZGVzdG9yeSgpIHtcbiAgICAgICAgdGhpcy4jb2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgICAgIHRoaXMuI2NoYW5nZWQuY2xlYXIoKVxuICAgICAgICB0aGlzLiNsaXN0ZW5lciA9IHt9XG4gICAgICAgIHRoaXMuI3ByaW1vcmRpYWwgPSB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOmqjOivgemTvuaOpeaYr+WQpuespuWQiOinhOiMg1xuICAgICAqIEBwYXJhbSBpbWcg5Zu+54mH6ZO+5o6lXG4gICAgICovXG4gICAgcHVibGljIHZhbGlkKGltZzogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNydWxlcy5yZWR1Y2UoKGFyLCBmbikgPT4gYXIgJiYgZm4oaW1nKSwgdHJ1ZSlcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQXlEQTtBQXhEQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUtBO0FBQ0E7QUErQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWxHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQWlGQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBMU1BO0FBQ0E7QUFEQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ })

/******/ })["default"];
});